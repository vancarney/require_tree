// Generated by CoffeeScript 1.6.2
var Events, eventSplitter, eventsApi, triggerEvents;

Events = {
  on: function(name, callback, context) {
    var events;

    if (!eventsApi(this, 'on', name, [callback, context]) || !callback) {
      return this;
    }
    this._events || (this._events = {});
    events = this._events[name] || (this._events[name] = []);
    events.push({
      callback: callback,
      context: context,
      ctx: context || this
    });
    return this;
  },
  off: function(name, callback, context) {
    var events, evt, keys, names, ord, retain, _ref;

    if (!this._events || !eventsApi(this, 'off', name, [callback, context])) {
      return this;
    }
    if (!name && !callback && !context) {
      this._events = {};
      return this;
    }
    keys = function(o) {
      var a, n, x;

      a = [];
      for (n in o) {
        x = o[n];
        a.push(n);
      }
      return a;
    };
    _ref = (names = name ? [name] : keys(this._events));
    for (ord in _ref) {
      name = _ref[ord];
      if ((events = this._events[name])) {
        this._events[name] = retain = [];
        if (callback || context) {
          for (evt in events) {
            if ((callback && callback !== evt.callback) && (callback !== evt.callback._callback) || (context && context !== evt.context)) {
              retain.push(evt);
            }
          }
        }
        if (!retain.length) {
          delete this._events[name];
        }
      }
    }
    return this;
  },
  trigger: function(name) {
    var allEvents, args, events;

    if (!this._events) {
      return this;
    }
    args = [].slice.call(arguments, 1);
    if (!eventsApi(this, 'trigger', name, args)) {
      return this;
    }
    events = this._events[name];
    allEvents = this._events.all;
    if (events) {
      triggerEvents(events, args);
    }
    if (allEvents) {
      triggerEvents(allEvents, arguments);
    }
    return this;
  }
};

eventSplitter = /\s+/;

eventsApi = function(obj, action, name, rest) {
  var idx, key, names;

  if (!name) {
    return true;
  }
  if (typeof name === 'object') {
    for (key in name) {
      obj[action].apply(obj, [key, name[key]].concat(rest));
    }
    false;
  }
  if (eventSplitter.test(name)) {
    names = name.split(eventSplitter);
    for (idx in names) {
      obj[action].apply(obj, [names[idx]].concat(rest));
    }
    false;
  }
  return true;
};

triggerEvents = function(events, args) {
  var a1, a2, a3, ev, i, l, _results;

  i = -1;
  l = events.length;
  a1 = args[0];
  a2 = args[1];
  a3 = args[2];
  switch (args.length) {
    case 0:
      while (++i < l) {
        (ev = events[i]).callback.call(ev.ctx);
      }
      break;
    case 1:
      while (++i < l) {
        (ev = events[i]).callback.call(ev.ctx, a1);
      }
      break;
    case 2:
      while (++i < l) {
        (ev = events[i]).callback.call(ev.ctx, a1, a2);
      }
      break;
    case 3:
      while (++i < l) {
        (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);
      }
      break;
    default:
      _results = [];
      while (++i < l) {
        _results.push((ev = events[i]).callback.apply(ev.ctx, args));
      }
      return _results;
  }
};

Events.bind = Events.on;

Events.unbind = Events.off;

exports.require_tree = function(uPath, options) {
  var appendPackage, dirname, extend, fs, getPackage, getPwd, initial, packages, parsePath, path, walker, _root,
    _this = this;

  if (uPath == null) {
    uPath = null;
  }
  if (options == null) {
    options = {};
  }
  'use strict';
  module.exports.locals = options.locals || {};
  fs = require('fs');
  path = require('path');
  initial = function(a) {
    return a.splice(0, a.length - 1);
  };
  extend = function(obj) {
    var o, x, _i, _len, _ref;

    _ref = Array.prototype.slice.call(arguments, 1);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      o = _ref[_i];
      if (o != null) {
        for (x in o) {
          obj[x] = o[x];
        }
      }
    }
    return obj;
  };
  extend(this, Events);
  if ((options.completed != null) && typeof options.completed === 'function') {
    this.on('completed', options.completed, this);
  }
  if ((options.changed != null) && typeof options.changed === 'function') {
    this.on('changed', options.changed, this);
  }
  dirname = function(p) {
    return (path.dirname(p)).replace(/^\.+$/, '');
  };
  _root = (path.normalize(uPath || '.')).split(path.sep).join(path.sep);
  module.exports.packages = packages = extend(options.packages || {}, {
    require_tree: extend({}, Events)
  });
  parsePath = function(p) {
    return p.replace(new RegExp("^\\.?(\\" + path.sep + ")"), '').split(path.sep);
  };
  getPwd = function(p) {
    return p.replace(new RegExp("^(\\.\\" + path.sep + ")?" + ((parsePath(_root)).join('\\' + path.sep)) + "\\" + path.sep), '');
  };
  appendPackage = function(p) {
    var d, pkg, s, _i, _name, _ref, _ref1;

    pkg = packages;
    for (d = _i = 0, _ref = (s = parsePath(p)).length; 0 <= _ref ? _i < _ref : _i > _ref; d = 0 <= _ref ? ++_i : --_i) {
      if ((_ref1 = pkg[_name = s[d]]) == null) {
        pkg[_name] = {};
      }
      pkg = pkg[s[d]];
    }
    return pkg;
  };
  getPackage = function(p) {
    var d, f, pkg, s, _i, _ref;

    pkg = packages;
    for (d = _i = 0, _ref = (s = parsePath(p)).length; 0 <= _ref ? _i < _ref : _i > _ref; d = 0 <= _ref ? ++_i : --_i) {
      if ((f = pkg[s[d]]) != null) {
        pkg = f;
      } else {
        if (s[d].length) {
          return null;
        }
      }
    }
    return pkg;
  };
  walker = function(dir) {
    var e, file, list, m, name, o, p, pwd, r, stat, v, x, _i, _len;

    if ((list = fs.readdirSync(dir)).length) {
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        name = list[_i];
        if (name.match(/^\./)) {
          continue;
        }
        file = path.join(dir, name);
        pwd = getPwd(file);
        try {
          stat = fs.statSync(file);
        } catch (_error) {
          e = _error;
          throw new Error(e);
          return false;
        }
        if (stat != null ? stat.isDirectory() : void 0) {
          appendPackage(pwd);
          walker(file);
        } else {
          if (!path.extname(file).match(/^\.js+(on)?$/)) {
            continue;
          }
          try {
            if (!options.preserve_filenames) {
              if (typeof (x = require(fs.realpathSync("" + file))) !== 'function') {
                o = extend(getPackage(dirname(pwd)), x);
              } else {
                (m = {})[name.split('.').shift()] = x;
                o = extend(getPackage(dirname(pwd)), m);
              }
            } else {
              if (name.match(/^index+/)) {
                o = getPackage(((p = parsePath(pwd)).slice(0, p.length - (p.length > 1 ? 1 : 0))).join(path.sep));
                o = extend(o, r = require(fs.realpathSync("" + file)));
              } else {
                o = (o = getPackage(dirname(pwd))) != null ? o : appendPackage((parsePath(pwd)).join(path.sep));
                v = extend(o[name.split('.').shift()] || {}, require(fs.realpathSync("" + file)));
                o[name.split('.').shift()] = v;
              }
            }
          } catch (_error) {
            e = _error;
            throw new Error(e);
            return false;
          }
        }
      }
    }
    return true;
  };
  packages.require_tree.getPackage = exports.getTree = function(p) {
    return getPackage("" + ((p != null ? p : p = '.').replace(/\./, path.sep)));
  };
  packages.require_tree.addTree = exports.addTree = function(p) {
    var b, _name, _ns, _oR, _ref;

    _oR = _root;
    _root = initial(b = p.split(path.sep)).join(path.sep);
    if ((_ref = packages[_name = _ns = b]) == null) {
      packages[_name] = (packages[_ns = b] = {});
    }
    if (walker(p)) {
      _root = _oR;
      Events.trigger.call(this, 'changed', {
        packages: packages,
        added: packages[b] || {}
      });
      return exports.packages = packages;
    }
    _root = _oR;
    return false;
  };
  packages.require_tree.extendTree = exports.extendTree = function(obj) {
    packages = extend(packages, obj);
    return Events.trigger.call(this, 'changed', {
      packages: packages,
      added: obj
    });
  };
  packages.require_tree.removeTree = exports.removeTree = function(p) {
    var e, pkg, rm, s;

    pkg = getPackage(initial(s = p.replace(/\./g, path.sep).split(path.sep)).join(path.sep));
    try {
      if ((rm = pkg[s[s.length - 1]]) != null) {
        delete pkg[s[s.length - 1]];
        return Events.trigger.call(this, 'changed', {
          packages: packages,
          removed: rm
        });
      }
    } catch (_error) {
      e = _error;
      throw new Error(e);
    }
  };
  extend(packages.require_tree, Events);
  if (uPath != null) {
    walker(uPath, null, null);
  }
  Events.trigger.call(this, 'completed', packages);
  return packages;
};
