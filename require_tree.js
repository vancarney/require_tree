// Generated by CoffeeScript 1.6.2
exports.require_tree = function(uPath, options) {
  var appendPackage, dirname, extend, fs, getPackage, getPwd, initial, packages, parsePath, path, walker, _root,
    _this = this;

  if (options == null) {
    options = {};
  }
  'use strict';
  module.exports.locals = options.locals || {};
  fs = require('fs');
  path = require('path');
  initial = function(a) {
    return a.splice(0, a.length - 1);
  };
  extend = function(obj) {
    var o, x, _i, _len, _ref;

    _ref = Array.prototype.slice.call(arguments, 1);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      o = _ref[_i];
      if (o != null) {
        for (x in o) {
          obj[x] = o[x];
        }
      }
    }
    return obj;
  };
  dirname = function(p) {
    return (path.dirname(p)).replace(/^\.+$/, '');
  };
  _root = (uPath = path.normalize(uPath != null ? uPath : uPath = '.')).split(path.sep).join(path.sep);
  module.exports.packages = packages = extend(options.packages || {}, {
    require_tree: {}
  });
  parsePath = function(p) {
    return p.replace(new RegExp("^\\.?(\\" + path.sep + ")"), '').split(path.sep);
  };
  getPwd = function(p) {
    return p.replace(new RegExp("^(\\.\\" + path.sep + ")?" + ((parsePath(_root)).join('\\' + path.sep)) + "\\" + path.sep), '');
  };
  appendPackage = function(p) {
    var d, pkg, s, _i, _name, _ref, _ref1;

    pkg = packages;
    for (d = _i = 0, _ref = (s = parsePath(p)).length; 0 <= _ref ? _i < _ref : _i > _ref; d = 0 <= _ref ? ++_i : --_i) {
      if ((_ref1 = pkg[_name = s[d]]) == null) {
        pkg[_name] = {};
      }
      pkg = pkg[s[d]];
    }
    return pkg;
  };
  getPackage = function(p) {
    var d, f, pkg, s, _i, _ref;

    pkg = packages;
    for (d = _i = 0, _ref = (s = parsePath(p)).length; 0 <= _ref ? _i < _ref : _i > _ref; d = 0 <= _ref ? ++_i : --_i) {
      if ((f = pkg[s[d]]) != null) {
        pkg = f;
      } else {
        if (s[d].length) {
          return null;
        }
      }
    }
    return pkg;
  };
  walker = function(dir) {
    var e, file, list, m, name, o, p, pwd, r, stat, v, x, _i, _len;

    if ((list = fs.readdirSync(dir)).length) {
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        name = list[_i];
        if (name.match(/^\./)) {
          continue;
        }
        file = path.join(dir, name);
        pwd = getPwd(file);
        try {
          stat = fs.statSync(file);
        } catch (_error) {
          e = _error;
          throw new Error(e);
          return false;
        }
        if (stat != null ? stat.isDirectory() : void 0) {
          appendPackage(pwd);
          walker(file);
        } else {
          if (!path.extname(file).match(/^\.js+(on)?$/)) {
            continue;
          }
          try {
            if (!options.preserve_filenames) {
              if (typeof (x = require(fs.realpathSync("" + file))) !== 'function') {
                o = extend(getPackage(dirname(pwd)), x);
              } else {
                (m = {})[name.split('.').shift()] = x;
                o = extend(getPackage(dirname(pwd)), m);
              }
            } else {
              if (name.match(/^index+/)) {
                o = getPackage(((p = parsePath(pwd)).slice(0, p.length - (p.length > 1 ? 1 : 0))).join(path.sep));
                o = extend(o, r = require(fs.realpathSync("" + file)));
              } else {
                o = (o = getPackage(dirname(pwd))) != null ? o : appendPackage((parsePath(pwd)).join(path.sep));
                v = extend(o[name.split('.').shift()] || {}, require(fs.realpathSync("" + file)));
                o[name.split('.').shift()] = v;
              }
            }
          } catch (_error) {
            e = _error;
            throw new Error(e);
            return false;
          }
        }
      }
    }
    return true;
  };
  packages.require_tree.getPackage = exports.getTree = function(p) {
    return getPackage("" + ((p != null ? p : p = '.').replace(/\./, path.sep)));
  };
  packages.require_tree.addTree = exports.addTree = function(p) {
    var b, _name, _ns, _oR, _ref;

    _oR = _root;
    _root = initial(b = p.split(path.sep)).join(path.sep);
    if ((_ref = packages[_name = _ns = b]) == null) {
      packages[_name] = (packages[_ns = b] = {});
    }
    if (walker(p)) {
      _root = _oR;
      return exports.packages = packages;
    }
    _root = _oR;
    return false;
  };
  packages.require_tree.extendTree = exports.extendTree = function(obj) {
    return packages = extend(packages, obj);
  };
  packages.require_tree.removeTree = exports.removeTree = function(p) {
    var e, pkg, s;

    pkg = getPackage(initial(s = p.replace(/\./g, path.sep).split(path.sep)).join(path.sep));
    try {
      if (pkg[s[s.length - 1]]) {
        return delete pkg[s[s.length - 1]];
      }
    } catch (_error) {
      e = _error;
      throw new Error(e);
    }
  };
  if (uPath != null) {
    walker(uPath, null, null);
  }
  return packages;
};
